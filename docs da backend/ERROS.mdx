---
title: "Códigos de Erro da API"
description: "Referência dos códigos e formato de erros (AppError) da BackBet."
slug: "/docs/erros"
---

# ERROS (AppError) — BackBet

O BackBet utiliza a classe `AppError` para padronizar respostas de falha em toda a stack (casos de uso, serviços e adaptadores HTTP). Cada erro carrega `code`, `message`, `statusCode` e `details?`, permitindo instrumentação consistente, métricas e documentação OpenAPI.

## Pipeline de tratamento

1. **Validação** — Schemas Zod ou validações de domínio usam `new AppError('VALIDATION_ERROR', ...)` detalhando quais campos falharam.
2. **Casos de uso** — Quando uma regra de negócio bloqueia a ação (saldo insuficiente, aposta inexistente), o caso de uso propaga um `AppError` com contexto em `details`.
3. **Infraestrutura** — Adaptadores (database, Redis, APIs externas) traduzem falhas conhecidas para códigos sem expor mensagens internas.
4. **Middleware global** — `src/shared/http/error-handler.ts` intercepta qualquer `AppError`, normaliza o payload e anexa `requestId`, `timestamp`, `traceId` e metadados de ambiente.

## Formato da resposta

```json
{
  "success": false,
  "error": {
    "code": "BAD_REQUEST",
    "message": "Descrição legível do erro",
    "details": { "campo": "mensagem de validação" }
  },
  "meta": {
    "timestamp": "2025-11-15T12:00:00.000Z",
    "requestId": "req_123",
    "traceId": "trace_abc"
  }
}
```

## Catálogo de códigos

| Código | HTTP | Quando usar | Detalhes recomendados |
| --- | --- | --- | --- |
| `VALIDATION_ERROR` | 400 | Falha em schemas Zod ou invariantes | mapa campo → mensagem, `rule` opcional |
| `BAD_REQUEST` | 400 | Regras de negócio quebradas (ex.: estado inválido) | `reason`, `expectedState`, `currentState` |
| `UNAUTHORIZED` | 401 | Token ausente, inválido ou dev bypass desativado | `authMode`, `hint` mínimo |
| `FORBIDDEN` | 403 | Papel não permite a ação | `requiredPermission`, `userRole` |
| `NOT_FOUND` | 404 | Qualquer recurso inexistente | `resource`, `identifier` |
| `CONFLICT` | 409 | Duplica chave ou condição otimista quebrada | `resource`, `field`, `value` |
| `RATE_LIMIT_EXCEEDED` | 429 | Limite de IP/usuário atingido | `retryAfter` em segundos |
| `SERVICE_UNAVAILABLE` | 503 | Dependência externa fora do ar (Clerk, Redis) | `dependency`, `retryAfter` |
| `INTERNAL_SERVER_ERROR` | 500 | Erro inesperado; log completo somente no observability stack | `requestId` apenas |

> Sempre use códigos específicos antes de cair no fallback `INTERNAL_SERVER_ERROR`.

## Exemplos

### Validação (400)

```json
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados inválidos",
    "details": {
      "email": "Formato inválido",
      "username": "Obrigatório"
    }
  },
  "meta": { "timestamp": "2025-11-15T12:01:00.000Z" }
}
```

### Conflito (409)

```json
{
  "success": false,
  "error": {
    "code": "CONFLICT",
    "message": "Email já cadastrado"
  },
  "meta": { "timestamp": "2025-11-15T12:02:00.000Z" }
}
```

### Rate limit (429)

```json
{
  "success": false,
  "error": {
    "code": "RATE_LIMIT_EXCEEDED",
    "message": "Limite de requisições atingido",
    "details": { "retryAfter": 60 }
  },
  "meta": { "timestamp": "2025-11-15T12:03:00.000Z" }
}
```

## Observabilidade

- **Logs estruturados**: cada `AppError` gera um log com `error.code`, `requestId`, `userId?`, `useCase` e `latencyMs`.
- **Snapshots internos**: `resilienceMetricsSnapshot` registra falhas/erros por código ao longo do tempo; esses dados alimentarão o PM2 WebUI e alertas por e-mail.
- **Tracing**: o middleware anexa `error.code` e `status` nos spans OTEL, permitindo filtrar sessões problemáticas em segundos.

## Documentação OpenAPI

- `components.schemas.ErrorResponse` descreve a estrutura `<success, error, meta>` e deve ser referenciada em cada endpoint 4xx/5xx.
- Para validações campo → mensagem, reutilize `ValidationErrorMap` (schema auxiliar) ou adicione `additionalProperties` em `details`.
- Quando criar um novo código, atualize `docs/API_DOCS.mdx` e a coleção de testes de contrato.

## Boas práticas

1. Lance somente `AppError` em regra de negócio previsível; use `logger.error` para exceções não tratadas antes do fallback 500.
2. Nunca exponha mensagens de infraestrutura ou stack traces no `message`; o detalhe sensível deve viver no log.
3. Prefira `details` minimalistas e estáveis, para que clientes possam automatizar o tratamento.
4. Inclua testes de contrato (Jest + supertest) cobrindo o payload de erro, especialmente para novos códigos.

## Como propor um novo código

1. Abra uma issue descrevendo o cenário e o comportamento esperado.
2. Ajuste `AppErrorCode` e o middleware de mapeamento HTTP, adicionando testes.
3. Atualize esta página, o schema OpenAPI e qualquer doc relacionada (API, Quickstart, Architecture).
4. Peça revisão dos mantenedores para garantir compatibilidade com os clientes existentes.

Arquivo relacionado: `src/shared/errors/AppError.ts`
