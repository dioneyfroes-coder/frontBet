Pontos de acoplamento/problemáticos (o que revisar)

token.ts e getAccessToken() acessam window.Clerk diretamente — acoplamento a uma impl. global.
handleLogout() faz redirect via window.location.replace('/login') → side-effect global (já mitigado parcialmente).
apiFetch mistura responsabilidades (fetch + retry + zod validation + chamada de handleError) — ok, mas precisa de limites explícitos.
Logs e debugging foram temporariamente incluídos (removidos já).
Falta de serialização de refresh: múltiplas requisições que recebem 401 podem disparar várias tentativas de refresh simultâneas (causou comportamento de redirect/reload observado).
Arquivos gerados (.react-router/\*) disparavam watcher → já mitigado em vite.config.ts.
Uso de localStorage direto em token.ts — bom para cliente, mas dificulta testes em algumas situações; já existe guard isBrowser().
Recomendações concretas (ordenadas por impacto)

Alta prioridade — Evitar refresh concorrente (recomendado)
Problema: várias requests 401 podem causar múltiplas tentativas de refresh e redirecionamentos.
Solução: implementar um “single in-flight refresh” em token.ts:
manter let refreshInFlight: Promise<string | null> | null.
refreshTokens() devolve refreshInFlight se já existir, senão cria a Promise e a compartilha.
garante que apenas uma request faz network para /api/auth/refresh.
Benefício: evita redundância, race conditions e múltiplos handleLogout().
Médio impacto — Injeção de provider de token em vez de heurísticas globais
Problema: getAccessToken() tenta heurísticas window.Clerk.
Solução: exigir registro de provider (já existe registerAccessTokenProvider) como primeira opção e documentar/forçar o uso no root (ex.: ClerkTokenRegistrar registra provider). Reduz uso de heurísticas e torna testagem mais previsível.
Médio impacto — Extrair side-effects de handleLogout
Problema: handleLogout mistura limpeza e redirect.
Solução: separar responsabilidades:
clearAuthState() que apenas limpa tokens/estado.
redirectToLogin() que faz window.location.replace.
handleLogout() por padrão chama ambos, mas apps/testes podem substituir setLogoutHandler com comportamento customizado.
Benefício: testes mais fáceis e menor risco de redirects indesejados em SSR / ambiente de teste.
Médio/baixo — Barrels e export central
Problema: imports diretos espalhados (p.ex. ../lib/token) — ok, mas trabalhar com app/lib/index.ts que reexporta api, token, auth, error melhora discoverability.
Solução: adicionar app/lib/index.ts com exports.
Baixo — Evitar window espalhado e melhorar abstração
Problema: chamadas diretas window.location, window.Clerk.
Solução: criar um adaptador app/lib/browser.ts com wrappers isBrowser(), getPathname(), replaceLocation() — facilita mocks.
Infra / dev-experience
Documentar módulo: criar docs/modules.md com mapa rápido (onde fica api, auth, stores, ui).
Adicionar testes unitários para token.refreshTokens com mutex.
